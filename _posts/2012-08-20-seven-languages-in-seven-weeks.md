---
layout: post
title: "Seven Languages in Seven Weeks"
description: "Seven Languages in Seven Weeks"
category: books 
share: true
tags: [design, languages, seven languages in seven weeks]
---

I've just started to look at <a href="http://pragprog.com/book/btlang/seven-languages-in-seven-weeks" target="_blank">Seven Languages in Seven Weeks</a>, a book written by Bruce A. Tate for the Pragmatic Bookshelf. I like the idea behind the book. Rather than a very basic 'Hello World' type introduction the aim of the book is to give you a real feel for each of the languages, their strengths and the idea behind them. 

Increasingly it is becoming important to be a Polyglot Programmer, capable of working with multiple languages. I hoped that working through the book would help me hone my evaluation skills, perhaps identify some languages I'd like to take a closer look at and understand why the languages were designed the way they were. What did the author think was important? What sacrifices was he willing to make? What clever syntax did he come up with. I've never really stepped back and properly done this. Poor I know.

Tate has selected seven diverse languages. These are:

+ Ruby: A dynamic OO language with a focus on being easy to use and read. Meant to be a joy for a developer to use (focus on human needs)
+ Io: An OO language. Not commercially successful but with great concurrency features and intrinsic beauty. It is a prototype language like JavaScript.
+ Prolog: A declarative and general purpose logic programming language.One of the older languages included but extremely powerful. Strongly influenced Erlang.  
+ Scala: Built on top of the JVM. Integrates functional programming paradigms with object-oriented paradigms.
+ Erlang: One of the oldest languages on this list which is gathering steam as a functional language that gets concurrency, distribution, and fault tolerance right. The creators of CouchDB (A NoSQL database that uses JSON to store data) chose Erlang.
+ Clojure: A JVM language based on Lisp-dialect. Radical changes in the way we think about concurrency on the JVM. Most flexible programming model in the book. Has a huge ecosystem to lean on, including a huge Java library and widely available deployment platforms.
+ Haskell: A pure functional language with no mutable state. Same function with same input parameters will give you the same output everytime. 

I'm looking forwards to learning more about some of the compelling answers Tate feels these languages provide including Io's implementation of futures, Scala's actors, or Erlang's 'Let it crash' philosophy. Understand how Haskell programmers leave mutable state behind or how Clojure uses versioning to solve some of the most difficult concurrency problems.

So as you can see there are lots of different programming models to get my head round: object-oriented (OO), functional, procedural, and hybrid. Logic-based (Prolog), full support for object-oriented concepts (Ruby, Scala), four languages that are functional in nature (Scala, Erlang, Clojure, Haskell), and a prototype language (Io). A multiparadigm language (Scala) and Clojure's multimethods which let you implement your own paradigm. Previously I've concentrated on OO languages so I'm looking forwards to learning something completely different.

In order to cover the ground needed to in order to let you get a real feel for the languages the reader is expected to work out things like installation themselves. Seems fair enough to me. 

I'll be posting about some of the things I find interesting over the coming weeks.

